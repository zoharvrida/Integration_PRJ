/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package bdsm.web;

import bdsm.model.FixQXtract;
import bdsm.model.MasterUser;
import bdsm.rpt.model.FixMasterReport;
import bdsm.rpt.model.FixReportReqMaster;
import bdsm.util.*;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.opensymphony.xwork2.ActionSupport;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.http.HttpServletRequest;
import org.apache.commons.io.FilenameUtils;
import org.apache.struts2.interceptor.validation.SkipValidation;
import org.apache.struts2.json.JSONException;
import org.apache.struts2.json.JSONUtil;
import sun.misc.BASE64Decoder;

/**
 *
 * @author bdsm
 */
public class DownloadContentAction extends BaseContentAction {

    private static final String ACTION_SAVE = "fixReportParam_save.action";
    private static final String ACTION_LIST = "fixReportDownload_list.action";
    private static final String ACTION_GET_FILEPATH = "fixReportParam_get.action";
    private static final String ACTION_GETDOWNLOAD = "fileDownload_get.action";
	private static final String ACTION_UPDATE = "fixReportDownload_insert.action";
	private static final String ACTION_REPORT = "fixMasterReport_get.action";
    
    private static Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd'T'HH:mm:ss").create();
    // parameter need for report
    private String idUser;
    private String idScheduler;
    private String cdBranch;
    
    private static final DateFormat DATE_FORMATTER = new java.text.SimpleDateFormat("dd-MM-yyyy HH:mm:ss");
	private static final String LINE_SEPARATOR = System.getProperty("line.separator");
	
    private HttpServletRequest servletRequest;
    private Map<String, Object> session;
    
    private FixQXtract modelQ;
    private FixReportReqMaster modelM;
    private FixMasterReport modelR;
    
    private String bdsmHost;
    private String tokenKey;
    private String tzToken;
    private String reqResult;
    private String errorCode;
    private String idReport;
    private String parameter;
    private String format;
    private String resultS;
    
    private String mandatory;
    private String maxLength;
    private String regexp;
    private String idMaintainedBy;
    private String idMaintainedSpv;
    private String user;
    private String dummy;
    private String reportName;
    private String remarks;
    private String btnSave;
    
    private String idTemplate;
    private String namUser;
    
    private String dtBusiness;
    private String namTemplate;
    private String namReportSearch;
    private String NAM_MENU;
    private String flag;
    
	private String dtmRequest;
	private String fileName;
	private InputStream fileInputStream;
	private String filePath;
	private String usertemp;
	private String reason;
	private String idBatch;
    

    /**
     * 
     * Constructor : for generate report based screen
     * @param servletRequest (servletRequest get from other method)
     * @param session (active map session get from other method)
     * @param bdsmHost (map bdsmHost)
     * @param tokenKey (tokenKey generated by system)
     * @param tzToken (tz (time zone) Token generate by system)
     * @param idReport (report ID)
     * @param idScheduler (Scheduler ID for processing)
     * @param idMaintainedBy (user modifier)
     * @param idMaintainedSpv (spv modifier)
     * @param idTemplate (template ID for scheduler)
     * @param cdBranch (branch No from screen)
     * @param dtBusiness (datprocess in BA_BANK_MAST)
     * @param namTemplate (template Name used by process)
     * @param NAM_MENU (menu name)
     * @param flag (flag for processing)
     * @param dtmRequest (sysdate)
     */
    public DownloadContentAction(HttpServletRequest servletRequest, Map<String, Object> session, String bdsmHost, String tokenKey, String tzToken, String idReport, String idScheduler, String idMaintainedBy, String idMaintainedSpv, String idTemplate, String cdBranch, String dtBusiness, String namTemplate, String NAM_MENU, FixQXtract flag, String dtmRequest) {
        this.servletRequest = servletRequest;
        this.session = session;
        this.bdsmHost = bdsmHost;
        this.tokenKey = tokenKey;
        this.tzToken = tzToken;
        this.modelQ = flag; 
        try {
            this.modelR = getReports(idReport);
            this.idScheduler = this.modelR.getCompositeId().getIdScheduler().toString();
            getLogger().debug("REPORT MODEL :" + modelR);
        } catch (JSONException jSONException) {
            getLogger().debug("JSON EX :" + jSONException,jSONException);
        } catch (Exception ex){
            getLogger().debug("RPT EX :" + ex,ex);
            this.modelR = new FixMasterReport();
            this.idScheduler = "";
        }
        this.idReport = idReport;
        this.resultS = mergeDown();
        
        this.idMaintainedBy = idMaintainedBy;
        this.idMaintainedSpv = idMaintainedSpv;
        this.idUser = this.session.get(Constant.C_IDUSER).toString();
        this.idTemplate = idTemplate;
        this.namUser = this.session.get(Constant.C_NAMUSER).toString();
        this.cdBranch = this.session.get(Constant.C_CODEBRANCH).toString();
        this.dtBusiness = dtBusiness;
        this.namTemplate = namTemplate;
        this.NAM_MENU = NAM_MENU;
        this.dtmRequest = dtmRequest;
        
    }

    
    /**
     * Function : execution method for download 
     * @return SUCCESS type from com.opensymphony.xwork2.ActionSupport
     */
    @Override
    public String exec() {
        doAdd();
        boolean flagStop = true;
        while (flagStop) {
            try {
                doList();
                if(!doList().isEmpty()){
                    flagStop = false;
                } else {
                    getLogger().debug("LOOP EXEC :" + flagStop);
                    Thread.sleep(10000);
                }            
            } catch (Exception exception) {
                getLogger().debug("eXCEPTION Thread :" + exception,exception);
                flagStop = false;
            }
        }
        downloadContent();
        return ActionSupport.SUCCESS;
    }

    /**
     * Function : Processing for request download Content
     * @return SUCCESS type from com.opensymphony.xwork2.ActionSupport
     */
    @Override
    public String doAdd() {
        
        Map<String, String> map = new HashMap<String, String>();
        HashMap resultMap;

        String reqResult = null;
        String errorCode = null;
        int k = 0;
        String result;
        String regexps = "|";
        String[] paramS = resultS.split(regexps);
        StringBuilder batchQ = new StringBuilder();

        getLogger().info("idUser 2:" + idUser);
        getLogger().info("idTemplate 2:" + idTemplate);
        getLogger().info("namUser 2:" + getNamUser());
        getLogger().info("cdBranch 2:" + cdBranch);
        getLogger().info("dtBusiness 2:" + dtBusiness);
        getLogger().info("namTemplate 2:" + namTemplate);

        try {
            map.put("modelQ.idScheduler", modelR.getCompositeId().getIdScheduler().toString());
        } catch (Exception e) {
            map.put("modelQ.idScheduler", this.idScheduler);
        }
        int length = paramS.length;
        for (int i = 0; i < length; i++) {
            k = i + 1;
            if (!"".equals(paramS[i])) {
                map.put("modelQ.param" + k, paramS[i]);
            } else {
                map.put("modelQ.param" + k, "null");
            }
            getLogger().info(paramS[i]);
        }
        map.put("idUser", idUser);
        map.put("idTemplate", idTemplate);
        map.put("namUser", getNamUser());
        map.put("cdBranch", cdBranch);
        map.put("dtProcess", dtBusiness);
        map.put("namTemplate", namTemplate);
        //map.put("modelM.idRequest", getUser());
        map.put("modelM.idReport", getIdReport());
        map.put("modelR.reportName", getReportName());
        map.put("modelR.remarks", getRemarks());
        map.put("modelQ.idMaintainedBy", getIdMaintainedBy());
        map.put("modelQ.idMaintainedSpv", getIdMaintainedSpv());
        map.put("namMenu", NAM_MENU);
        map.put("sequential", getDummy());
        map.put("token", BdsmUtil.generateToken(getTokenKey(), getTzToken()));

        result = HttpUtil.request(getBdsmHost() + ACTION_SAVE, map);

        try {
            resultMap = (HashMap) JSONUtil.deserialize(result);
            reqResult = (String) resultMap.get("jsonStatus");
            errorCode = (String) resultMap.get("errorCode");
        } catch (JSONException ex) {
            getLogger().fatal(ex, ex);
        } catch (NullPointerException e) {
            getLogger().info(" NULL P : " + e.getMessage());
        }

        if (reqResult.equals(ActionSupport.ERROR)) {
            addActionError(getText(errorCode));
        } else if (reqResult.equals(ActionSupport.SUCCESS)) {
            addActionMessage(getText(errorCode));
        }
        return ActionSupport.SUCCESS;
    }

    /**
     * 
     * @return
     */
    @Override
    public String doEdit() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    /**
     * 
     * @return
     */
    @Override
    public String doDelete() {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    /**
     * 
     * @return
     * @throws Exception
     */
    public List doList() throws Exception {
        Map<String, String> params = new HashMap<String, String>();
        String result;

        getLogger().debug("user Request : " + this.user);
        getLogger().debug("flag : " + this.getFlag());

        params.put("flag", this.getFlag());
        params.put("model.idRequest", this.user);
        params.put("token", BdsmUtil.generateToken(getTokenKey(), getTzToken()));

        result = HttpUtil.request(getBdsmHost() + ACTION_LIST, params);

        HashMap ret = (HashMap) JSONUtil.deserialize(result);
        List listRet = (List) ret.get("modelList");
        String statusRet = (String) ret.get("jsonStatus");
        addActionError(statusRet);

        return listRet;
    }

    private String downloadContent(){
        String[] relative;
		StringBuilder pPath = new StringBuilder();
		this.getLogger().info("Reason :" + reason);
		this.getLogger().info("path :" + filePath);
		this.getLogger().info("user :" + usertemp);
		this.getLogger().info("idBatch :" + idBatch);
		this.getLogger().info("filename :" + fileName);
		int i = 0;
		int j = 0;
		String time = SchedulerUtil.getTime().toString();
		String truepath = null;
		String filepathHostRetriever = "";

		try {
			Map<String, String> mapBatch = new HashMap<String, String>();
			HashMap mapModelBatch;

			mapBatch.put("modelM.compositeId.idBatch", idBatch);
			mapBatch.put("token", BdsmUtil.generateToken(getTokenKey(), getTzToken()));

			String result = HttpUtil.request(getBdsmHost() + ACTION_GET_FILEPATH, mapBatch);
			Map resultMap = (Map) JSONUtil.deserialize(result);
			mapModelBatch = (HashMap) resultMap.get("modelResp");
			filepathHostRetriever = (String) mapModelBatch.get("filePath");
		}
		catch (Exception e) {
			this.getLogger().info(" NULL P : " + e.getMessage());
		}

		relative = filepathHostRetriever.split("\\/");
		for (int k = 0; i < relative.length - 1; i++)
			pPath.append(relative[k]).append("/");
		
		this.getLogger().info("relative_name : " + relative[relative.length - 1]);
		// String onlyPath = pPath.toString();
		String onlyPath = FilenameUtils.getPath(filepathHostRetriever);
		this.getLogger().info("only Path : " + onlyPath);
		// pPath.append(realPath()).append(usertemp);
		String realPath = filepathHostRetriever;
		String trueFilename = relative[relative.length - 1];
		String JSONTag = "";
		
		this.getLogger().info("RELATIVE PATH :" + filePath);
		this.getLogger().info("Cek Reason :" + reason);

		if (!"".equals(reason)) {
			truepath = error(onlyPath, time);
			String regexps = "\\.";
			// this.getLogger().info("Pathing : " + realPath());

			String[] format = null;
			try {
				format = truepath.split(regexps);
			}
			catch (NullPointerException e) {
				this.getLogger().info("FileName Empty");
			}
			
			i = format.length - 1;
			j = i - 1;
			try {
				StringBuilder reportContentFromHost = new StringBuilder();

				reportContentFromHost.append("Time: " + DATE_FORMATTER.format(new java.util.Date()) + LINE_SEPARATOR);
				reportContentFromHost.append("Error: " + reason);
				byte[] tmp = reportContentFromHost.toString().getBytes();

				// tmp = new
				// BASE64Decoder().decodeBuffer(reportContentFromHost);

				InputStream is = new ByteArrayInputStream(tmp);
				setFileInputStream(is);
				doAdd();

			}
			catch (Exception fileNotFoundException) {
				this.getLogger().error(this.getClass().getSimpleName() + ":File cannot be found");
				doEdit();
				return SUCCESS;
			}
			this.getLogger().info("Error Log :" + truepath);
			// update dtmFinish
			return "downloadtxt";
		}
		else {
			String regexps = "\\.";
			this.getLogger().info("Pathing : " + realPath);

			String[] format = null;
			try {
				format = trueFilename.split(regexps);
			}
			catch (NullPointerException e) {
				this.getLogger().info("FileName Empty");
			}
			
			i = format.length - 1;
			j = i - 1;

			this.getLogger().info(realPath);
			this.getLogger().info("Format : " + format[i]);
			try {
				// File file = new File(realPath);
				// setFileInputStream(new FileInputStream(file));
				Map<String, String> map = new HashMap<String, String>();
				String reportContentFromHost = "";
				
				HashMap mapModel;

				map.put("model.reportPath", realPath);
				map.put("model.reportType", format[i].toUpperCase());
				map.put("token", BdsmUtil.generateToken(getTokenKey(), getTzToken()));
				String result = HttpUtil.request(getBdsmHost() + ACTION_GETDOWNLOAD, map);
				Map resultMap = (Map) JSONUtil.deserialize(result);
				mapModel = (HashMap) resultMap.get("model");
				reportContentFromHost = (String) mapModel.get("reportContent");
				JSONTag = (String) mapModel.get("reportJSON");
				
				byte[] tmp = new BASE64Decoder().decodeBuffer(reportContentFromHost);

				InputStream is = new ByteArrayInputStream(tmp);
				// InputStream is2 = new FileInputStream(new
				// File("D:\\BDSM\\log.zip"));
				setFileInputStream(is);
			}
			catch (Exception fileNotFoundException) {
				this.getLogger().error(this.getClass().getSimpleName() + ":File cannot be found");
				this.addActionError(this.getClass().getSimpleName() + ":File cannot be found");
				doEdit();
				return ERROR;
			}
			
			doAdd(); // update dtmFinish
			this.getLogger().info("Format : " + format[i]);
			if ("failed".equals(JSONTag)){
				this.getLogger().info("FILE EXTENSION unsupported!!!");
				this.addActionError("FILE EXTENSION unsupported!!!");
				doEdit();
				return ERROR;
			} else {
				return JSONTag;
			}
		}
    }
    
    /**
     * 
     * @param path
     * @param time
     * @return
     */
    @SkipValidation
	public String error(String path, String time) {
		this.getLogger().info("[ Begin ] Error Log Creation()");
		this.getLogger().info("Reason(for Error): " + this.reason);
		
		try {
			if (isValidSession()) {
				Map<String, String> map = new HashMap<String, String>();
				HashMap resultMap;
				HashMap resPath = null;
				String reqResult = null;
				String errorCode = null;
				String realPath = null;

				this.getLogger().info("ID_BATCH :" + this.idBatch);
				String result = null;
				map.put("time", time);
				map.put("reason", this.reason);
				map.put("realPath", path);
				map.put("token", BdsmUtil.generateToken(getTokenKey(), getTzToken()));
				map.put("model.compositeId.idBatch", this.idBatch);

				// result = HttpUtil.request(getBdsmHost() + ACTION_EXEC, map);
				result = HttpUtil.request(getBdsmHost() + ACTION_UPDATE, map);

				try {
					resultMap = (HashMap) JSONUtil.deserialize(result);
					reqResult = (String) resultMap.get("jsonStatus");
					errorCode = (String) resultMap.get("errorCode");
					resPath = (HashMap) resultMap.get("path");
					realPath = (String) resultMap.get("fullPath");

					this.getLogger().info("Path for download :" + realPath);
				}
				catch (JSONException ex) {
					this.getLogger().fatal(ex, ex);
				}
				catch (NullPointerException e) {
					this.getLogger().info(" NULL P : " + e.getMessage());
				}

				if (reqResult.equals(ERROR))
					addActionError(getText(errorCode));
				else if (reqResult.equals(SUCCESS))
					addActionMessage(getText(errorCode));
				
				return realPath;
			}
			else {
				return logout();
			}
		}
		catch (NullPointerException e) {
			this.getLogger().info("null Pointer" + e);
			// setErrorMessage("CIF: " + getNoCif() + " not found");
			return ERROR;
		}
		catch (Throwable e) {
			this.getLogger().fatal(e, e);
			return ERROR;
		}
		finally {
			this.getLogger().info("[ End ] Error Creation()");
		}
		//
	}
    /**
     * 
     * @return
     */
    public String breakDown(){
        StringBuilder mainParam = new StringBuilder();
        mainParam.append(this.session.get(Constant.C_IDUSER)).append("~");

        mainParam.append(this.modelR.getCompositeId().getIdScheduler()).append("~");
        String reportfileresult = null;
        try {
            reportfileresult = modelR.getReportName();
            reportfileresult = reportfileresult.replace("{branch}", this.cdBranch);
            reportfileresult = reportfileresult.replace("{user}", this.session.get(Constant.C_IDUSER).toString());
            
            reportfileresult = reportfileresult.replace("{param1}", modelQ.getParam1());
            reportfileresult = reportfileresult.replace("{param2}", modelQ.getParam2());
            reportfileresult = reportfileresult.replace("{param3}", modelQ.getParam3());
            reportfileresult = reportfileresult.replace("{param4}", modelQ.getParam4());
            reportfileresult = reportfileresult.replace("{param5}", modelQ.getParam5());
        } catch (Exception e) {
            getLogger().debug("EXCEPTION PARAM :" + e,e);
            reportfileresult = modelR.getReportName();
        }
        mainParam.append(FileUtil.getDateTimeFormatedString(reportfileresult + "{yyMMdd-HHmmss}")).append("~");  
        mainParam.append(this.modelR.getCompositeId().getIdReport()).append("~");
        mainParam.append(modelR.getRemarks()).append("~");
        mainParam.append(this.session.get(Constant.C_CODEBRANCH)).append("~");
        mainParam.append(this.session.get(Constant.C_NAMUSER)).append("~");
        mainParam.append(this.session.get(Constant.C_DATEBUSINESS)).append("~");
        mainParam.append(this.session.get(Constant.C_IDTEMPLATE)).append("~");
        mainParam.append(this.session.get(Constant.C_NAMUSER)).append("~");
        try {
            mainParam.append(this.modelQ.getParam1());
        } catch (Exception e) {
            getLogger().debug("NO PARAM1 :" + e,e);
            mainParam.append("");
        } 
        return mainParam.toString();
    }
    private String mergeDown(){
        StringBuilder mainParam = new StringBuilder();
        mainParam.append(modelQ.getParam1()).append("|").append(modelQ.getParam2()).append("|").
                append(modelQ.getParam3()).append("|").append(modelQ.getParam4()).append("|").append(modelQ.getParam5()).append("|")
                .append(modelQ.getParam6()).append("|");
        return mainParam.toString();
    }
    private FixMasterReport getReports(String idReport) throws JSONException {
        Map<String, String> map = new HashMap<String, String>();
        map.put("model.compositeId.idReport", idReport);
        map.put("token", BdsmUtil.generateToken(getTokenKey(), getTzToken()));
        String result = HttpUtil.request(getBdsmHost() + ACTION_REPORT, map);
        Map resultMap = (Map) JSONUtil.deserialize(result);
        Map modelMap = (Map) resultMap.get("model");
        String modelJson = gson.toJson(modelMap);
        getLogger().debug("json REPORT :" + modelJson);
        return (FixMasterReport) gson.fromJson(modelJson, FixMasterReport.class);
    }
    
    @Override
    public HttpServletRequest getServletRequest() {
        return servletRequest;
    }

    /**
     * 
     * @return
     */
    @Override
    public String getBdsmHost() {
        return bdsmHost;
    }

    /**
     * 
     * @return
     */
    @Override
    public String getTokenKey() {
        return tokenKey;
    }

    /**
     * 
     * @return
     */
    @Override
    public String getTzToken() {
        return tzToken;
    }

    /**
     * 
     * @return
     */
    public String getReqResult() {
        return reqResult;
    }

    /**
     * 
     * @param reqResult
     */
    public void setReqResult(String reqResult) {
        this.reqResult = reqResult;
    }

    /**
     * 
     * @return
     */
    public String getErrorCode() {
        return errorCode;
    }

    /**
     * 
     * @param errorCode
     */
    public void setErrorCode(String errorCode) {
        this.errorCode = errorCode;
    }

    /**
     * @return the namUser
     */
    public String getNamUser() {
        return namUser;
    }

    /**
     * @param namUser the namUser to set
     */
    public void setNamUser(String namUser) {
        this.namUser = namUser;
    }

    /**
     * @return the idScheduler
     */
    public String getIdScheduler() {
        return idScheduler;
    }

    /**
     * @param idScheduler the idScheduler to set
     */
    public void setIdScheduler(String idScheduler) {
        this.idScheduler = idScheduler;
    }

    /**
     * @return the idReport
     */
    public String getIdReport() {
        return idReport;
    }

    /**
     * @param idReport the idReport to set
     */
    public void setIdReport(String idReport) {
        this.idReport = idReport;
    }

    /**
     * @return the reportName
     */
    public String getReportName() {
        return reportName;
    }

    /**
     * @param reportName the reportName to set
     */
    public void setReportName(String reportName) {
        this.reportName = reportName;
    }

    /**
     * @return the remarks
     */
    public String getRemarks() {
        return remarks;
    }

    /**
     * @param remarks the remarks to set
     */
    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    /**
     * @return the idMaintainedBy
     */
    public String getIdMaintainedBy() {
        return idMaintainedBy;
    }

    /**
     * @param idMaintainedBy the idMaintainedBy to set
     */
    public void setIdMaintainedBy(String idMaintainedBy) {
        this.idMaintainedBy = idMaintainedBy;
    }

    /**
     * @return the idMaintainedSpv
     */
    public String getIdMaintainedSpv() {
        return idMaintainedSpv;
    }

    /**
     * @param idMaintainedSpv the idMaintainedSpv to set
     */
    public void setIdMaintainedSpv(String idMaintainedSpv) {
        this.idMaintainedSpv = idMaintainedSpv;
    }

    /**
     * @return the dummy
     */
    public String getDummy() {
        return dummy;
    }

    /**
     * @param dummy the dummy to set
     */
    public void setDummy(String dummy) {
        this.dummy = dummy;
    }

    /**
     * @return the flag
     */
    public String getFlag() {
        return flag;
    }

    /**
     * @param flag the flag to set
     */
    public void setFlag(String flag) {
        this.flag = flag;
    }

    /**
     * @return the dtmRequest
     */
    public String getDtmRequest() {
        return dtmRequest;
    }

    /**
     * @param dtmRequest the dtmRequest to set
     */
    public void setDtmRequest(String dtmRequest) {
        this.dtmRequest = dtmRequest;
    }

    /**
     * @return the fileInputStream
     */
    public InputStream getFileInputStream() {
        return fileInputStream;
    }

    /**
     * @param fileInputStream the fileInputStream to set
     */
    public void setFileInputStream(InputStream fileInputStream) {
        this.fileInputStream = fileInputStream;
    }
}
